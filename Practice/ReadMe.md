## 1. Основы Java

1.1. Написать сортировку пузырьком и бинарный поиск элемента в массиве.  
1.2. Реализовать иерархию объектов Circle, Rect, Triangle, Square.  
1.3. Реализовать конвертеры температуры. Считаем, что значения будут поступать по шкале Цельсия, конвертеры должны преобразовывать значение в свою шкалу.

## 2. Работа с коллекциями

2.1. Имеется список парка машин Car(String model, String type).
Необходимо разбить его на списки сгруппированные по type.
Пример исходного списка: Лада седан, Лада хэтчбек, Мерседес седан, Бмв кроссовер,  Форд хэтчбек, Пежо кроссовер, Тойота седан и т.п.  
2.2. Имеется список парка машин Car(String model, String type). Необходимо разбить его на списки сгруппированные по type.
Исходные данные: текстовый файл со средней длиной строки равной 10 символам (файл или прошить текст в коде).    
2.2.1. Подсчитайте количество различных слов в файле.  
2.2.2. Выведите на экран список различных слов файла, отсортированный по возрастанию их длины (компаратор сначала по длине слова, потом по тексту).  
2.2.3. Подсчитайте и выведите на экран сколько раз каждое слово встречается в файле.  
2.2.4. Выведите на экран все строки файла в обратном порядке.  
2.2.5: Реализуйте свой Iterator для обхода списка в обратном порядке.    
2.2.6: Выведите на экран строки, номера которых задаются пользователем в произвольном порядке.

## 3 Generics
3.1. Параметризовать CountMap и реализовать его.    
3.2. Параметризовать методы, используя правило PECS, и реализовать их.  

## 4 Работа с Exceptions
4.1. Реализовать интерфейс Terminal, c помощью которого можно:
проверить состояние счета; cнять/положить деньги.  
4.1.1 Доступ к терминалу (терминал для одного счета) предоставляется только
после ввода корректного пин-кода (4 цифры).  
4.1.2 При вводе нецифрового символа система должна выдать предупреждение,
но при этом данное действие не считается критичной ошибкой ввода и
состояние системы должно восстановиться к последнему корректному состоянию.  
4.1.3 При вводе 3 неправильных пин-кодов аккаунт блокируется на 10 сек
(при попытке обратиться к нему в течение этого времени должно вызываться
исключение AccountIsLockedException c информацией об оставшемся времени
до снятия блокировки).  
4.1.4 Класть и снимать деньги можно только, если сумма кратна 100.  
4.1.5 Поскольку банкоматы, установленные на улице, сами «ничего не делают»
с вашим счетом (они лишь делают проверку введенных данных и отправляют
запросы на удаленный), то сервер (TerminalServer) может вызывать свои
исключения, например, при недостатке средств на счете для совершения операции.    
4.2. Реализуйте метод readContent(String url), который отображает на экран
содержимое сайта, ссылка на который задаётся параметром url.  
Напишите программу, считывающую из консоли строку (URL ресурса) и вызывающую
метод readContent. В том случае, если введённый URL неправильного формата
или нет доступа до указанного ресурса, пользователю предлагается повторить ввод.

## 5 Рефлексия, аннотации, прокси
5.1. Имплементировать интерфейс Calculator в классе CalculatorImpl.  
5.2. Вывести на консоль все методы класса, включая все родительские методы (включая приватные).  
5.3. Вывести все геттеры класса.  
5.4. Проверить что все String константы имеют значение = их имени public static final String MONDAY = "MONDAY".  
5.5. Реализовать кэширующий прокси.  
5.6. Создать свою аннотацию Metric. Реализовать proxy класс PerformanceProxy,
который в случае если метод аннотирован Metric будет выводить на консоль
время выполнения метода.  
5.7. Реализовать класс BeanUtils по документации

## 6 Средства сборки, тестирование
6.1. Спроектировать дизайн соц. сети. В данном задании интересует разбитие приложения на модули, взаимодействие интерфейсов, а не реализация конкретных классов.
Соц. сети обычно предлагают большой набор сервисов: поиск/добавление друзей, просмотр профилей,  загрузка и просмотр фото, общение через чат или стены, рекомендации, подарки и куча других сервисов. Все эти сервисы должны находится в отдельных модулях и иметь связи между собой.
Ваша задача создать maven проект, создать модули для каждого сервиса, прописать зависимости одних модулей от других. В каждом модуле должны быть интерфейсы и доменная модель данного сервиса + в некоторых модулях нужна примерная реализация интерфейсов, где показано как используются интерфейсы других модулей.
Написать юнит тесты к классам из данного задания (с помощью junit + mockito)  
6.2. Реализуйте свой итератор массива объектов.
Напишите тесты для проверки его работоспособности.
Оформите сборку кода через maven.

## 7 Загрузчики классов
7.1 Ваша задача написать загрузчик плагинов в вашу систему. Допустим вы пишите свой браузер, и хотите чтобы люди имели
возможность писать плагины для него. Соответственно, разные разработчики могут назвать свои классы одинаковым именем, ваш загрузчик должен корректно это обрабатывать.  
7.2 Написать EncryptedClassloader. Данный класслоадер умеет загружать классы из файлов дешифрую их. Ваша задача переопределить метод findClass(). В нем лоадер считывает зашифрованный массив байт, дешифрует его и превращает в класс (с помощью метода defineClass).На вход класслодер принимает ключ шифрования, рутовую папку, в которой будет искать классы, родительский класслодер. Логика шифрования/дешифрования с использованием ключа может быть любой на ваш вкус (например, каждый считаный байт класса увеличить на определение число).

## 8 Сериализация
Создать кеширующий прокси. Необходимо реализовать возможность тонкой настройки кеша:
8.1. Указывать с помощью аннотаций, какие методы кешировать и как: просчитанный результат хранить в памяти JVM или сериализовывать в файле на диск.  
8.2. Возможность указывать, какие аргументы метода учитывать при определении уникальности результата,
а какие игнорировать(по умолчанию все аргументы учитываются).
Например, должна быть возможность указать, что doHardWork() должен игнорировать значение второго аргумента,
уникальность определяется только по String аргументу.

> double r1 = service.doHardWork("work1", 10); //считает результат  
> double r2 = service.doHardWork("work1", 5);  // результат из кеша, несмотря на то что второй аргумент различается

8.3. Если возвращаемый тип это List – возможность указывать максимальное количество элементов в нем. То есть, если нам возвращается List с size = 1млн, мы можем сказать что в кеше достаточно хранить 100т элементов.  
8.4. Возможность указывать название файла/ключа по которому будем храниться значение. Если не задано - использовать имя метода.  
8.5. Если мы сохраняем результат на диск, должна быть возможность указать, что данный файл надо дополнительно сжимать в zip архив.  
8.6. Любые полезные настройки на ваш вкус.  
8.7. Все настройки кеша должны быть optional и иметь дефолтные настройки.  
8.8. Все возможные исключения должны быть обработаны с понятным описание, что делать, чтобы избежать ошибок.
(Например, если вы пытаетесь сохранить на диск результат метода, но данный результат не сериализуем,
надо кинуть исключение с понятным описанием как это исправить.)  
8.9. Логика по кешированию должна навешиваться с помощью DynamicProxy. Должен быть класс CacheProxy с методом cache(),
который принимает ссылку на сервис и возвращает кешированную версию этого сервиса.
CacheProxy должен тоже принимать в конструкторе некоторые настройки, например рутовую папку в которой хранить файлы,
дефолтные настройки кеша и тд.
> CacheProxy cacheProxy = new CacheProxy(...);  
> Service service = cacheProxy.cache(new ServiceImpl());  
> Loader loader = cacheProxy.cache(new LoaderImpl());

## 9. Лямбда функции, стримы
Реализовать класс похожий на java.util.stream.Stream (http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html).
Использование этого класса должно выглядеть примерно так:
> List<Person> someCollection = ...   
> Map m = Streams.of(someCollection)  
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .filter(p -> p.getAge() > 20)  
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .transform( p -> new Person(p.geAge() + 30)))  
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .toMap(p -> p.geName(), p -> p);

## 10. Многопоточность (часть 1)
Дан файл содержащий несколько случайных натуральных чисел от 1 до 50.
Необходимо написать многопоточное приложение, которое параллельно рассчитает
и выведет в консоль факториал для каждого числа из файла.

## 11. Многопоточность (часть 2)
Сделать 2 реализации ThreadPool.  
11.1 FixedThreadPool - Количество потоков задается в конструкторе и не меняется.  
11.2 ScalableThreadPool в конструкторе задается минимальное и максимальное(int min, int max) число потоков,
количество запущенных потоков может быть увеличено от
минимального к максимальному, если при добавлении нового задания в очередь нет свободного потока для
исполнения этого задания. При отсутствии задания в
очереди, количество потоков опять должно быть уменьшено до значения min.

## 12. Модель памяти в Java
12.1. Ваша задача реализовать класс Task имеющий один метод get():
> public class Task<T> {  
&nbsp;&nbsp;&nbsp;&nbsp;    …  
&nbsp;&nbsp;&nbsp;&nbsp;     public Task(Callable<? extends T> callable) {  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         //...    
&nbsp;&nbsp;&nbsp;&nbsp;      }  
&nbsp;&nbsp;&nbsp;&nbsp;     public T get() {  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         // todo implement me  
&nbsp;&nbsp;&nbsp;&nbsp;     }  
 }
 
Данный класс в конструкторе принимает экземпляр java.util.concurrent.Callable.
Callable похож на Runnuble, но результатом его работы является объект (а не void).
Ваша задача реализовать метод get() который возвращает результат работы Callable.
Выполнение callable должен начинать тот поток, который первый вызвал метод get().  
Если несколько потоков одновременно вызывают этот метод, то выполнение должно
начаться только в одном потоке, а остальные должны ожидать конца выполнения
(не нагружая процессор).  
Если при вызове get() результат уже просчитан, то он должен вернуться сразу,
(даже без задержек на вход в синхронизированную область).  
Если при просчете результата произошел Exception, то всем потокам при вызове get(),
надо кидать этот Exception, обернутый в ваш RuntimeException (подходящее название своему ексепшену придумайте сами).

12.2. Ваша задача реализовать интерфейс ExecutionManager
> public interface ExecutionManager {  
&nbsp;&nbsp;&nbsp;&nbsp;     Context execute(Runnable callback, Runnable... tasks);  
 }

Метод execute принимает массив тасков, это задания которые
ExecutionManager должен выполнять параллельно (в вашей реализации
пусть будет в своем пуле потоков). После завершения всех тасков
должен выполниться callback (ровно 1 раз).  
Метод execute – это неблокирующий метод, который сразу возвращает
объект Context. Context это интерфейс следующего вида:

> public interface Context {  
&nbsp;&nbsp;&nbsp;&nbsp;     int getCompletedTaskCount();  
&nbsp;&nbsp;&nbsp;&nbsp;     int getFailedTaskCount();  
&nbsp;&nbsp;&nbsp;&nbsp;     int getInterruptedTaskCount();  
&nbsp;&nbsp;&nbsp;&nbsp;     void interrupt();  
&nbsp;&nbsp;&nbsp;&nbsp;     boolean isFinished();  
}

 Метод getCompletedTaskCount() возвращает количество тасков, которые на текущий момент успешно выполнились.  
 Метод getFailedTaskCount() возвращает количество тасков, при выполнении которых произошел Exception.  
 Метод interrupt() отменяет выполнения тасков, которые еще не начали выполняться.  
 Метод getInterruptedTaskCount() возвращает количество тасков, которые не были выполены из-за отмены (вызовом предыдущего метода).  
 Метод isFinished() вернет true, если все таски были выполнены или отменены, false в противном случае.  

## 13. JVM, JIT, GC
13.1. Сделать цикл на 100000 итераций, в цикле в предварительно созданную Map<Integer, String> сложить ключ - индекс, значение - "value" + индекс.
Запустить с опцией -XX:+PrintCompilation, проанализировать информацию в консоли. 
Запустить с опцией -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining , проанализировать информацию в консоли.  
13.2. Из %JAVA_HOME%\bin запустить jvisualvm, установить через пункт меню
Tools\Plugins\Available Plugis плагин: Visual GC
Запустить приложение создающее много объектов с разными GC,
посмотреть в jvisualvm как заполняются объекты в разных
областях памяти(heap).

## 14. java.util.concurrent
Модифицировать кэш, из предыдущих домашних заданий по рефлексии и сериализации (п.8),
сделать его конкурентным. Должна быть возможность не лочить весь кэш,
а только тот элемент который в данный момент добавляется или удаляется.

## 15. Паттерны проектирования, SOLID
Рефакторить код
15.1 https://bitbucket.org/agoshkoviv/patterns-homework-1/src/69a61334ea43ff4c3fd950a00095377cf1e3bfd4/src/main/java/ru/sbt/test/refactoring/?at=master
(применен паттерн состояние (state))

## 16. Работа с базами данных в Java
Разработать продвинутый кэш, который помнит о
кэшированных данных после перезапуска приложения
(применен паттерн фабричный метод)